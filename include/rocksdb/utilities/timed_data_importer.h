//  Copyright (c) Meta Platforms, Inc. and affiliates.
//  This source code is licensed under both the GPLv2 (found in the
//  COPYING file in the root directory) and Apache 2.0 License
//  (found in the LICENSE.Apache file in the root directory).

#pragma once

#include "rocksdb/db.h"

namespace ROCKSDB_NAMESPACE {

// A utility for importing data with historical write times into RocksDB.
// Along with Iterator::GetProperty for entry write times, this enables
// data to be migrated from one DB instance to another while importing
// into an apprpriate tier in the target DB based on the original age
// of the data. This class is not thread-safe and not intended for users
// to derive from.
class TimedDataImporter {
 public:
  virtual ~TimedDataImporter() {}

  // Record an entry for import. Must be called in sorted key order, between
  // successful Commit() or Reset(). Will typically
  // * assign a seqno based on the DBâ€™s SeqnoToTimeMapping,
  // * decide which Temperature is appropriate based on that and target CF
  // options,
  // * add to an SST file writer for that Temperature.
  virtual Status TimedPut(const Slice& user_key, const Slice& value,
                          uint64_t write_unix_time) = 0;
  virtual Status TimedPut(const Slice& user_key, const Slice& timestamp,
                          const Slice& value, uint64_t write_unix_time) = 0;

  // Finish writing SST files and attempt to ingest them into the appropriate
  // LSM tiers/levels. OK status means the data has been successfully imported
  // into the DB+CF and persisted with a M?ANIFEST sync, and this
  // TimedDataImporter has returned to an empty state (like Reset()).
  // IMPORTANT: The operation will only succeed if the target CF has no files
  // overlapping the entire begin-to-end key range of data to import. Thus,
  // * The target DB might need to use SstFilePartitioner to ensure SST files
  // are cut whenever there are recognized gaps that might be filled by import.
  // * A single TimedDataImporter Commit is only allowed to fit in one of
  // those gaps in the target CF's existing data, so might need to be split
  // up into multiple Commit batches if there are gaps in the imported data
  // that might overlap with existing data in the CF.
  // However, files generated by TimedDataImporter use the target CF's
  // SstFilePartitioner, so that any recognized gaps even within a single
  // Commit can be filled by later imports.
  virtual Status Commit() = 0;

  // Abandon any recorded entries and return to original (empty) state.
  virtual Status Reset() = 0;
};

// Create a TimedDataImporter for importing data into the specified DB+CF.
// The TimedDataImporter must be destroyed before the DB and CF.
std::unique_ptr<TimedDataImporter> MakeTimedDataImporter(
    DB* target_db, ColumnFamilyHandle* target_cf);

}  // namespace ROCKSDB_NAMESPACE
